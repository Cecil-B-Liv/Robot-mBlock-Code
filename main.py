# generated by mBlock5 for CyberPi
# codes make you happy

import event, time, cyberpi, mbot2, mbuild, random, threading

# initialize variables
base_power = 30
current_speed = base_power 
kp = 0.3
left_power = 0
right_power = 0
red_count = 0

@event.start
def on_start():
    global base_power, kp, left_power, right_power
    cyberpi.console.set_font(12)
    cyberpi.console.println("A：Stop Navigating")
    cyberpi.console.println("B：Start Navigating")
    cyberpi.console.println("Press joystick：")
    cyberpi.console.println("Check the color recognition results")

# @event.is_press('a')
# def is_a_press():
#     global base_power, kp, left_power, right_power
#     cyberpi.stop_other()
#     mbot2.drive_power(0, 0)

@event.is_press('b')
def is_b_press():
    global current_speed, base_power, kp, left_power, right_power, red_count
    cyberpi.stop_other()
    current_speed = base_power
    kp = 0.3

    while not cyberpi.controller.is_press('a'):
      if mbuild.ultrasonic2.get(1) < 10: # Stop when see obstacle
        mbot2.EM_stop("all") 
        cyberpi.console.println("Obstacle detected!")
        continue
      
      # If see green and white
      elif mbuild.quad_rgb_sensor.is_color("green", "L1") or mbuild.quad_rgb_sensor.is_color("green", "R1") or \
        mbuild.quad_rgb_sensor.is_color("white", "L1") or mbuild.quad_rgb_sensor.is_color("white", "R1"):
        # Green or White: Normal speed
        if mbuild.quad_rgb_sensor.is_color("green", "L1") or mbuild.quad_rgb_sensor.is_color("green", "R1"):
            cyberpi.led.show("green")
        else:
            cyberpi.led.show("white")
        current_speed = base_power # Reset to initial speed when seeing green or white

      elif mbuild.quad_rgb_sensor.is_color("red","L1") or mbuild.quad_rgb_sensor.is_color("red","R1"):
        cyberpi.led.show("red")
        cyberpi.console.println("Red detected - stopping")
        mbot2.EM_stop("all")
        time.sleep(5)
        cyberpi.console.println("Backing up")
        mbot2.backward(50, 0.2)
        time.sleep(5)
        current_speed = base_power
        if (red_count == 0):
          red_count = red_count + 1
        else:
           red_count = 0
          #  mbot2.turn(180) remember to check
                    
      elif mbuild.quad_rgb_sensor.is_color("yellow","L1") or mbuild.quad_rgb_sensor.is_color("yellow","R1"):
        cyberpi.led.show("yellow")
        cyberpi.console.println("Yellow detected - slowing down")
        
        current_speed = current_speed/2
        # Create and start the timer to restore speed after 5 seconds
        timer = threading.Timer(5.0, lambda: setattr(__builtins__, 'speed', base_power))
        timer.start()
        print("Slowing down for 5 seconds...")
        
        current_speed = base_power

      offset = mbuild.quad_rgb_sensor.get_offset_track(1)
      left_power = (base_power - kp * offset)
      right_power =  -1 * (base_power + kp * offset)
      mbot2.drive_power(left_power, right_power)

      time.sleep(0.05)
        
    mbot2.EM_stop("all") 
    cyberpi.console.println("Navigation stopped") # Stop when exiting the loop

@event.is_press('middle')
def is_joy_press():
    cyberpi.stop_other()
    mbot2.drive_power(0, 0)
    while not cyberpi.controller.is_press('a'):
      # Show colors from all sensors for debugging
      colors = [
          # "L2: " + str(mbuild.quad_rgb_sensor.get_color_sta("L2", 1)),
          "L1: " + str(mbuild.quad_rgb_sensor.get_color_sta("L1", 1)), 
          "R1: " + str(mbuild.quad_rgb_sensor.get_color_sta("R1", 1)),
          # "R2: " + str(mbuild.quad_rgb_sensor.get_color_sta("R2", 1))
      ]
      
      cyberpi.console.clear()
      for color in colors:
          cyberpi.console.println(color)